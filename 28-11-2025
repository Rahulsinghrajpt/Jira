Investigating the date column transformation logic. Reviewing the code that handles date/week column processing:
Reviewing the exact logic that processes week columns:
Checking if there's a standardization function that also processes week columns:
Checking the column standardizer for week column handling:
Checking the standardization function for week column processing:
Problem
The code in process_with_pandas (lines 687-710) finds any column containing "week" and renames the first match to "Date". This causes:
Columns like primeday_week, blackfriday_week are matched
The first match is renamed to "Date", creating a duplicate if "Date" already exists
Other "week" columns may be processed incorrectly
Root cause
# Line 688: This matches ANY column containing "week"week_columns_lower = [col for col in df_columns_lower if 'week' in col]
This matches:
week ✓ (intended)
primeday_week ✗ (unintended)
blackfriday_week ✗ (unintended)
Fix
Update the logic to:
Check if "Date" already exists — if yes, skip week processing
Only match a column named exactly "week" (case-insensitive), not columns containing "week"
Here's the corrected code:
# Around line 687-710 in lambda_function.py# Preserve original column names (data integrity requirement)original_columns = df.columns.tolist()# Create lowercase copy for checking only (DO NOT modify df.columns)df_columns_lower = df.columns.str.lower()# Check if "Date" column already existshas_date_column = 'date' in df_columns_lower# Only process week column if Date doesn't already existif not has_date_column:    # Find column named exactly "week" (case-insensitive), not columns containing "week"    week_col_index = None    original_week_col = None        for idx, col_lower in enumerate(df_columns_lower):        if col_lower == 'week':  # Exact match only            week_col_index = idx            original_week_col = original_columns[idx]            break        if week_col_index is not None and original_week_col:        logger.info(f"Found week column: {original_week_col}, renaming to 'Date'")        df = df.rename(columns={original_week_col: 'Date'})                # Update original_columns and df_columns_lower to reflect the rename        original_columns[week_col_index] = 'Date'        df_columns_lower = df.columns.str.lower()  # Recreate lowercase copy after rename                # Reformat date values to YYYY-MM-DD        try:            # Try parsing as date first            df['Date'] = pd.to_datetime(df['Date'], errors='coerce')            # Format to YYYY-MM-DD            df['Date'] = df['Date'].dt.strftime('%Y-%m-%d')            # Replace NaT with empty string            df['Date'] = df['Date'].fillna('')            logger.info(f"Reformatted {len(df)} date values to YYYY-MM-DD format")        except Exception as e:            logger.warning(f"Error reformatting dates: {e}")    else:        logger.info("No 'week' column found (exact match), Date column may already exist or not needed")else:    logger.info("Date column already exists, skipping week column processing")
Changes
Check for existing "Date" column first
Match only exact "week" (case-insensitive), not columns containing "week"
Skip processing if "Date" already exists
Add logging for clarity
Testing
After applying the fix, verify:
Files with "Date" column → no duplicate Date columns
Files with "week" column → renamed to "Date"
Files with "primeday_week", "blackfriday_week" → left unchanged
Files with both "Date" and "week" → "Date" kept, "week" not processed
Should I create a patch file with this fix, or do you want to apply it directly?
